; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\sys_config.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\sys_config.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\bsp_lib -I..\bsp_lib -I..\bsp_lib -I..\bsp_lib -I..\bsp_lib -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -IC:\Users\Administrator\Desktop\ssr-accounts\handheld_device\RVMDK\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=515 -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\sys_config.crf ..\bsp_lib\sys_config.c]
                          THUMB

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;79     
;;;80     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;81     {	
;;;82     	#ifdef  VECT_TAB_RAM  
;;;83     	/* Set the Vector Table base location at 0x20000000 */ 
;;;84     	NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;85     	#else  /* VECT_TAB_FLASH  */
;;;86     	/* Set the Vector Table base location at 0x08000000 */ 
;;;87     	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;88     	#endif
;;;89     	
;;;90     	/* Configure one bit for preemption priority */
;;;91     	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00000c  f44f60a0          MOV      r0,#0x500
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;92     	
;;;93     	return;
;;;94     }
000014  bd10              POP      {r4,pc}
;;;95     
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;30     *******************************************************************************************/
;;;31     void RCC_Configuration(void) 
000000  b570              PUSH     {r4-r6,lr}
;;;32     {
;;;33     	/* RCC system reset(for debug purpose) */
;;;34       	RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;35     
;;;36       	/* Enable HSE */
;;;37       	RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;38     
;;;39       	/* Wait till HSE is ready */
;;;40       	while (RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);
00000e  bf00              NOP      
                  |L2.16|
000010  2031              MOVS     r0,#0x31
000012  f7fffffe          BL       RCC_GetFlagStatus
000016  2800              CMP      r0,#0
000018  d0fa              BEQ      |L2.16|
;;;41     
;;;42         /* Enable Prefetch Buffer */
;;;43         FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;44     
;;;45         /* Flash 2 wait state */
;;;46         FLASH_SetLatency(FLASH_Latency_2);
000020  2002              MOVS     r0,#2
000022  f7fffffe          BL       FLASH_SetLatency
;;;47      
;;;48         /* HCLK = SYSCLK */
;;;49         RCC_HCLKConfig(RCC_SYSCLK_Div1);
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       RCC_HCLKConfig
;;;50       
;;;51         /* PCLK2 = HCLK */
;;;52         RCC_PCLK2Config(RCC_HCLK_Div1);
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       RCC_PCLK2Config
;;;53     
;;;54         /* PCLK1 = HCLK/2 */
;;;55         RCC_PCLK1Config(RCC_HCLK_Div2);
000032  f44f6080          MOV      r0,#0x400
000036  f7fffffe          BL       RCC_PCLK1Config
;;;56     
;;;57         /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;58         RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003a  f44f11e0          MOV      r1,#0x1c0000
00003e  f44f3080          MOV      r0,#0x10000
000042  f7fffffe          BL       RCC_PLLConfig
;;;59     
;;;60         /* Enable PLL */ 
;;;61         RCC_PLLCmd(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       RCC_PLLCmd
;;;62     
;;;63         /* Wait till PLL is ready */
;;;64         while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
00004c  bf00              NOP      
                  |L2.78|
00004e  2039              MOVS     r0,#0x39
000050  f7fffffe          BL       RCC_GetFlagStatus
000054  2800              CMP      r0,#0
000056  d0fa              BEQ      |L2.78|
;;;65     
;;;66         /* Select PLL as system clock source */
;;;67         RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000058  2002              MOVS     r0,#2
00005a  f7fffffe          BL       RCC_SYSCLKConfig
;;;68     
;;;69         /* Wait till PLL is used as system clock source */
;;;70         while(RCC_GetSYSCLKSource() != 0x08);
00005e  bf00              NOP      
                  |L2.96|
000060  f7fffffe          BL       RCC_GetSYSCLKSource
000064  2808              CMP      r0,#8
000066  d1fb              BNE      |L2.96|
;;;71     		
;;;72     	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI1, ENABLE);
;;;73     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |
000068  2101              MOVS     r1,#1
00006a  f241001d          MOV      r0,#0x101d
00006e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;74     												 RCC_APB2Periph_SPI1  | RCC_APB2Periph_AFIO, ENABLE);
;;;75     
;;;76     	SysTick_Config(SystemCoreClock / 1000);//1ms滴答
000072  4814              LDR      r0,|L2.196|
000074  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000076  f44f727a          MOV      r2,#0x3e8
00007a  fbb0f1f2          UDIV     r1,r0,r2
00007e  f1b17f80          CMP      r1,#0x1000000
000082  d300              BCC      |L2.134|
000084  e01d              B        |L2.194|
                  |L2.134|
000086  f021407f          BIC      r0,r1,#0xff000000
00008a  1e40              SUBS     r0,r0,#1
00008c  f04f22e0          MOV      r2,#0xe000e000
000090  6150              STR      r0,[r2,#0x14]
000092  1750              ASRS     r0,r2,#29
000094  220f              MOVS     r2,#0xf
000096  2800              CMP      r0,#0
000098  da07              BGE      |L2.170|
00009a  0713              LSLS     r3,r2,#28
00009c  0e1d              LSRS     r5,r3,#24
00009e  4b0a              LDR      r3,|L2.200|
0000a0  f000040f          AND      r4,r0,#0xf
0000a4  1f24              SUBS     r4,r4,#4
0000a6  551d              STRB     r5,[r3,r4]
0000a8  e003              B        |L2.178|
                  |L2.170|
0000aa  0713              LSLS     r3,r2,#28
0000ac  0e1c              LSRS     r4,r3,#24
0000ae  4b07              LDR      r3,|L2.204|
0000b0  541c              STRB     r4,[r3,r0]
                  |L2.178|
0000b2  bf00              NOP      
0000b4  2000              MOVS     r0,#0
0000b6  f04f22e0          MOV      r2,#0xe000e000
0000ba  6190              STR      r0,[r2,#0x18]
0000bc  2007              MOVS     r0,#7
0000be  6110              STR      r0,[r2,#0x10]
0000c0  bf00              NOP      
                  |L2.194|
;;;77     	return;
;;;78     }
0000c2  bd70              POP      {r4-r6,pc}
;;;79     
                          ENDP

                  |L2.196|
                          DCD      SystemCoreClock
                  |L2.200|
                          DCD      0xe000ed18
                  |L2.204|
                          DCD      0xe000e400

                          AREA ||i.ad_init||, CODE, READONLY, ALIGN=2

                  ad_init PROC
;;;131    
;;;132    void ad_init(void){
000000  b500              PUSH     {lr}
000002  b091              SUB      sp,sp,#0x44
;;;133    	ADC_InitTypeDef ADC_InitStructure;  
;;;134    	DMA_InitTypeDef DMA_InitStructure;  
;;;135    	GPIO_InitTypeDef GPIO_InitStructure; 
;;;136    	
;;;137    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); 
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;138    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0248              LSLS     r0,r1,#9
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;139    	
;;;140    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;  
000014  2001              MOVS     r0,#1
000016  f8ad0000          STRH     r0,[sp,#0]
;;;141    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;  
00001a  2000              MOVS     r0,#0
00001c  f88d0003          STRB     r0,[sp,#3]
;;;142    	GPIO_Init(GPIOB, &GPIO_InitStructure);	
000020  4669              MOV      r1,sp
000022  4833              LDR      r0,|L3.240|
000024  f7fffffe          BL       GPIO_Init
;;;143    	
;;;144    	//DMA1通道1配置  
;;;145    	DMA_DeInit(DMA1_Channel1);  
000028  4832              LDR      r0,|L3.244|
00002a  f7fffffe          BL       DMA_DeInit
;;;146    	//外设地址  
;;;147    	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_ADDRESS;  
00002e  4832              LDR      r0,|L3.248|
000030  9001              STR      r0,[sp,#4]
;;;148    	//内存地址  
;;;149    	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)ADCConvertedValue;  
000032  4832              LDR      r0,|L3.252|
000034  9002              STR      r0,[sp,#8]
;;;150    	//dma传输方向单向  
;;;151    	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;  
000036  2000              MOVS     r0,#0
000038  9003              STR      r0,[sp,#0xc]
;;;152    	//设置DMA在传输时缓冲区的长度  
;;;153    	DMA_InitStructure.DMA_BufferSize = 16;  
00003a  2010              MOVS     r0,#0x10
00003c  9004              STR      r0,[sp,#0x10]
;;;154    	//设置DMA的外设递增模式，一个外设  
;;;155    	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;  
00003e  2000              MOVS     r0,#0
000040  9005              STR      r0,[sp,#0x14]
;;;156    	//设置DMA的内存递增模式  
;;;157    	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;  
000042  2080              MOVS     r0,#0x80
000044  9006              STR      r0,[sp,#0x18]
;;;158    	//外设数据字长  
;;;159    	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;  
000046  0040              LSLS     r0,r0,#1
000048  9007              STR      r0,[sp,#0x1c]
;;;160    	//内存数据字长  
;;;161    	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;  
00004a  0080              LSLS     r0,r0,#2
00004c  9008              STR      r0,[sp,#0x20]
;;;162    	//设置DMA的传输模式：连续不断的循环模式  
;;;163    	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;  
00004e  2020              MOVS     r0,#0x20
000050  9009              STR      r0,[sp,#0x24]
;;;164    	//设置DMA的优先级别  
;;;165    	DMA_InitStructure.DMA_Priority = DMA_Priority_High;  
000052  0200              LSLS     r0,r0,#8
000054  900a              STR      r0,[sp,#0x28]
;;;166    	//设置DMA的2个memory中的变量互相访问  
;;;167    	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  
000056  2000              MOVS     r0,#0
000058  900b              STR      r0,[sp,#0x2c]
;;;168    	DMA_Init(DMA1_Channel1, &DMA_InitStructure); 	
00005a  a901              ADD      r1,sp,#4
00005c  4825              LDR      r0,|L3.244|
00005e  f7fffffe          BL       DMA_Init
;;;169    	//使能通道1  
;;;170    	DMA_Cmd(DMA1_Channel1, ENABLE);	
000062  2101              MOVS     r1,#1
000064  4823              LDR      r0,|L3.244|
000066  f7fffffe          BL       DMA_Cmd
;;;171    
;;;172    	//ADC1配置  
;;;173    	//独立工作模式  
;;;174    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  
00006a  2000              MOVS     r0,#0
00006c  900c              STR      r0,[sp,#0x30]
;;;175    	//扫描方式  
;;;176    	ADC_InitStructure.ADC_ScanConvMode = DISABLE; //单通道
00006e  f88d0034          STRB     r0,[sp,#0x34]
;;;177    	//连续转换  
;;;178    	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;  
000072  2001              MOVS     r0,#1
000074  f88d0035          STRB     r0,[sp,#0x35]
;;;179    	//外部触发禁止  
;;;180    	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;  
000078  f44f2060          MOV      r0,#0xe0000
00007c  900e              STR      r0,[sp,#0x38]
;;;181    	//数据右对齐  
;;;182    	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;  
00007e  2000              MOVS     r0,#0
000080  900f              STR      r0,[sp,#0x3c]
;;;183    	//用于转换的通道数  
;;;184    	ADC_InitStructure.ADC_NbrOfChannel = 1;  
000082  2001              MOVS     r0,#1
000084  f88d0040          STRB     r0,[sp,#0x40]
;;;185    	ADC_Init(ADC1, &ADC_InitStructure);  
000088  a90c              ADD      r1,sp,#0x30
00008a  481b              LDR      r0,|L3.248|
00008c  384c              SUBS     r0,r0,#0x4c
00008e  f7fffffe          BL       ADC_Init
;;;186          
;;;187    	//规则模式通道配置  
;;;188    	ADC_RegularChannelConfig(ADC1, ADC_Channel_8 , 1, ADC_SampleTime_239Cycles5);        
000092  2307              MOVS     r3,#7
000094  2201              MOVS     r2,#1
000096  2108              MOVS     r1,#8
000098  4817              LDR      r0,|L3.248|
00009a  384c              SUBS     r0,r0,#0x4c
00009c  f7fffffe          BL       ADC_RegularChannelConfig
;;;189    	//使能ADC1的DMA  
;;;190    	ADC_DMACmd(ADC1, ENABLE);        
0000a0  2101              MOVS     r1,#1
0000a2  4815              LDR      r0,|L3.248|
0000a4  384c              SUBS     r0,r0,#0x4c
0000a6  f7fffffe          BL       ADC_DMACmd
;;;191    	//使能ADC1  
;;;192    	ADC_Cmd(ADC1, ENABLE);  
0000aa  2101              MOVS     r1,#1
0000ac  4812              LDR      r0,|L3.248|
0000ae  384c              SUBS     r0,r0,#0x4c
0000b0  f7fffffe          BL       ADC_Cmd
;;;193          
;;;194    	//使能ADC1复位校准寄存器    
;;;195    	ADC_ResetCalibration(ADC1);  
0000b4  4810              LDR      r0,|L3.248|
0000b6  384c              SUBS     r0,r0,#0x4c
0000b8  f7fffffe          BL       ADC_ResetCalibration
;;;196    	//检查校准寄存器是否复位完毕  
;;;197    	while(ADC_GetResetCalibrationStatus(ADC1));  
0000bc  bf00              NOP      
                  |L3.190|
0000be  480e              LDR      r0,|L3.248|
0000c0  384c              SUBS     r0,r0,#0x4c
0000c2  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000c6  2800              CMP      r0,#0
0000c8  d1f9              BNE      |L3.190|
;;;198          
;;;199    	//开始校准  
;;;200    	ADC_StartCalibration(ADC1);  
0000ca  480b              LDR      r0,|L3.248|
0000cc  384c              SUBS     r0,r0,#0x4c
0000ce  f7fffffe          BL       ADC_StartCalibration
;;;201    	//检测是否校准完毕  
;;;202    	while(ADC_GetCalibrationStatus(ADC1));  
0000d2  bf00              NOP      
                  |L3.212|
0000d4  4808              LDR      r0,|L3.248|
0000d6  384c              SUBS     r0,r0,#0x4c
0000d8  f7fffffe          BL       ADC_GetCalibrationStatus
0000dc  2800              CMP      r0,#0
0000de  d1f9              BNE      |L3.212|
;;;203           
;;;204    	//开启ADC1的软件转换  
;;;205    	ADC_SoftwareStartConvCmd(ADC1, ENABLE); 
0000e0  2101              MOVS     r1,#1
0000e2  4805              LDR      r0,|L3.248|
0000e4  384c              SUBS     r0,r0,#0x4c
0000e6  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;206    
;;;207    	return;
;;;208    }
0000ea  b011              ADD      sp,sp,#0x44
0000ec  bd00              POP      {pc}
;;;209    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L3.240|
                          DCD      0x40010c00
                  |L3.244|
                          DCD      0x40020008
                  |L3.248|
                          DCD      0x4001244c
                  |L3.252|
                          DCD      ADCConvertedValue

                          AREA ||i.get_ad_val||, CODE, READONLY, ALIGN=2

                  get_ad_val PROC
;;;209    
;;;210    uint16_t get_ad_val(void){
000000  2200              MOVS     r2,#0
;;;211    	int i;
;;;212    	uint32_t sum = 0;
;;;213    	for(i=0;i<16;i++){
000002  2100              MOVS     r1,#0
000004  e004              B        |L4.16|
                  |L4.6|
;;;214    		sum += ADCConvertedValue[i];
000006  4805              LDR      r0,|L4.28|
000008  f8300011          LDRH     r0,[r0,r1,LSL #1]
00000c  4402              ADD      r2,r2,r0
00000e  1c49              ADDS     r1,r1,#1              ;213
                  |L4.16|
000010  2910              CMP      r1,#0x10              ;213
000012  dbf8              BLT      |L4.6|
;;;215    	}
;;;216    	return sum>>4;
000014  f3c2100f          UBFX     r0,r2,#4,#16
;;;217    }
000018  4770              BX       lr
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      ADCConvertedValue

                          AREA ||i.read_addr||, CODE, READONLY, ALIGN=2

                  read_addr PROC
;;;112    
;;;113    int read_addr(u8 *addr){
000000  b510              PUSH     {r4,lr}
000002  4603              MOV      r3,r0
;;;114    	u32 count=0;
000004  2100              MOVS     r1,#0
;;;115    	u16 tmp;
;;;116    	
;;;117    	while(count < 5){
000006  e009              B        |L5.28|
                  |L5.8|
;;;118    		tmp = *(u16 *)(0x8008000 + count*2);
000008  4c06              LDR      r4,|L5.36|
00000a  f8342011          LDRH     r2,[r4,r1,LSL #1]
;;;119    		if(tmp > 255){
00000e  2aff              CMP      r2,#0xff
000010  dd02              BLE      |L5.24|
;;;120    			return -1;
000012  f04f30ff          MOV      r0,#0xffffffff
                  |L5.22|
;;;121    		}
;;;122    		addr[count] = tmp&0xFF;
;;;123    		count++;
;;;124    	}
;;;125    	
;;;126    	return 0;
;;;127    }
000016  bd10              POP      {r4,pc}
                  |L5.24|
000018  545a              STRB     r2,[r3,r1]            ;122
00001a  1c49              ADDS     r1,r1,#1              ;123
                  |L5.28|
00001c  2905              CMP      r1,#5                 ;117
00001e  d3f3              BCC      |L5.8|
000020  2000              MOVS     r0,#0                 ;126
000022  e7f8              B        |L5.22|
;;;128    
                          ENDP

                  |L5.36|
                          DCD      0x08008000

                          AREA ||i.save_addr||, CODE, READONLY, ALIGN=2

                  save_addr PROC
;;;96     
;;;97     void save_addr(u8 *addr){
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;98     	u32 count=0;
000004  2400              MOVS     r4,#0
;;;99     	
;;;100    	RCC_HSICmd(ENABLE);	
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       RCC_HSICmd
;;;101    	FLASH_Unlock();
00000c  f7fffffe          BL       FLASH_Unlock
;;;102    	FLASH_ClearFlag(FLASH_FLAG_EOP|FLASH_FLAG_PGERR|FLASH_FLAG_WRPRTERR);	
000010  2034              MOVS     r0,#0x34
000012  f7fffffe          BL       FLASH_ClearFlag
;;;103    	FLASH_ErasePage(0x8008000);
000016  4808              LDR      r0,|L6.56|
000018  f7fffffe          BL       FLASH_ErasePage
;;;104    	while(count < 5){
00001c  e006              B        |L6.44|
                  |L6.30|
;;;105    		FLASH_ProgramHalfWord((0x8008000 +count*2),addr[count]);  //flash  为一个字节存储，16位数据必须地址加2
00001e  5d29              LDRB     r1,[r5,r4]
000020  4a05              LDR      r2,|L6.56|
000022  eb020044          ADD      r0,r2,r4,LSL #1
000026  f7fffffe          BL       FLASH_ProgramHalfWord
;;;106    		count++;
00002a  1c64              ADDS     r4,r4,#1
                  |L6.44|
00002c  2c05              CMP      r4,#5                 ;104
00002e  d3f6              BCC      |L6.30|
;;;107    	}
;;;108    	FLASH_Lock();
000030  f7fffffe          BL       FLASH_Lock
;;;109    
;;;110    	return;
;;;111    }
000034  bd70              POP      {r4-r6,pc}
;;;112    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x08008000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  ADCConvertedValue
                          %        32
