; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\output\stm32f10x_it.o --asm_dir=.\Listing\ --list_dir=.\Listing\ --depend=.\output\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\User -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\STM32F10x_StdPeriph_Driver\src -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\bsp_lib -I..\bsp_lib -I..\bsp_lib -I..\bsp_lib -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__UVISION_VERSION=515 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\output\stm32f10x_it.crf ..\User\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;140    *******************************************************************************/
;;;141    void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;142    {
;;;143        //当总线错误发生时进入死循环 
;;;144        while (1)
000002  e7fe              B        |L1.2|
;;;145        {
;;;146        }
;;;147    }
;;;148    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;181    *******************************************************************************/
;;;182    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;183    {
;;;184    }
;;;185    
                          ENDP


                          AREA ||i.Delay_Ms||, CODE, READONLY, ALIGN=2

                  Delay_Ms PROC
;;;47     
;;;48     void Delay_Ms(unsigned int delay){
000000  2100              MOVS     r1,#0
;;;49     
;;;50     	delay_cnt = 0;
000002  4a04              LDR      r2,|L3.20|
000004  6011              STR      r1,[r2,#0]  ; delay_cnt
;;;51     	while(delay>delay_cnt);
000006  bf00              NOP      
                  |L3.8|
000008  4902              LDR      r1,|L3.20|
00000a  6809              LDR      r1,[r1,#0]  ; delay_cnt
00000c  4288              CMP      r0,r1
00000e  d8fb              BHI      |L3.8|
;;;52     	return;
;;;53     }
000010  4770              BX       lr
;;;54     
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      delay_cnt

                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI0_IRQHandler PROC
;;;221    
;;;222    void EXTI0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224    	#if 0
;;;225    	if(!key.busy){
;;;226    		key.GPIOx = GPIOA;
;;;227    		key.GPIO_Pin = GPIO_Pin_0;
;;;228    		key.key_value = 0;
;;;229    		key.delay = 0;
;;;230    		key.busy = 1;
;;;231    	}	
;;;232    	#endif
;;;233    	EXTI_ClearITPendingBit(EXTI_Line0);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       EXTI_ClearITPendingBit
;;;234    	return;
;;;235    }
000008  bd10              POP      {r4,pc}
;;;236    
                          ENDP


                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI15_10_IRQHandler PROC
;;;243    
;;;244    void EXTI15_10_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;245    {
;;;246    	#if 0
;;;247    	if(!key.busy){
;;;248    		if(!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10)){
;;;249    			key.GPIOx = GPIOA;
;;;250    			key.GPIO_Pin = GPIO_Pin_10;
;;;251    			key.key_value = 6;
;;;252    		}else if(!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11)){
;;;253    			key.GPIOx = GPIOA;
;;;254    			key.GPIO_Pin = GPIO_Pin_11;
;;;255    			key.key_value = 3;
;;;256    		}else if(!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12)){
;;;257    			key.GPIOx = GPIOA;
;;;258    			key.GPIO_Pin = GPIO_Pin_12;
;;;259    			key.key_value = 13;
;;;260    		}else if(!GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11)){
;;;261    			key.GPIOx = GPIOB;
;;;262    			key.GPIO_Pin = GPIO_Pin_11;
;;;263    			key.key_value = 12;
;;;264    		}else if(!GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_12)){
;;;265    			key.GPIOx = GPIOB;
;;;266    			key.GPIO_Pin = GPIO_Pin_12;
;;;267    			key.key_value = 1;
;;;268    		}else if(!GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13)){
;;;269    			key.GPIOx = GPIOB;
;;;270    			key.GPIO_Pin = GPIO_Pin_13;
;;;271    			key.key_value = 4;
;;;272    		}else if(!GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_14)){
;;;273    			key.GPIOx = GPIOB;
;;;274    			key.GPIO_Pin = GPIO_Pin_14;
;;;275    			key.key_value = 7;
;;;276    		}else if(!GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_15)){
;;;277    			key.GPIOx = GPIOB;
;;;278    			key.GPIO_Pin = GPIO_Pin_15;
;;;279    			key.key_value = 10;
;;;280    		}
;;;281    		
;;;282    		
;;;283    		key.delay = 0;
;;;284    		key.busy = 1;
;;;285    	}
;;;286    	#endif
;;;287    	EXTI_ClearITPendingBit(EXTI_Line10 | EXTI_Line11 | EXTI_Line12 | EXTI_Line13 | EXTI_Line14 | EXTI_Line15);
000002  f44f407c          MOV      r0,#0xfc00
000006  f7fffffe          BL       EXTI_ClearITPendingBit
;;;288    	return;
;;;289    }
00000a  bd10              POP      {r4,pc}
;;;290    
                          ENDP


                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI9_5_IRQHandler PROC
;;;236    
;;;237    void EXTI9_5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;238    {
;;;239    
;;;240    	EXTI_ClearITPendingBit(EXTI_Line5 | EXTI_Line6 | EXTI_Line7 | EXTI_Line8 | EXTI_Line9 | EXTI_Line10);
000002  f44f60fc          MOV      r0,#0x7e0
000006  f7fffffe          BL       EXTI_ClearITPendingBit
;;;241    	return;
;;;242    }
00000a  bd10              POP      {r4,pc}
;;;243    
                          ENDP


                          AREA ||i.Get_SysTick||, CODE, READONLY, ALIGN=2

                  Get_SysTick PROC
;;;43     
;;;44     unsigned int Get_SysTick(void){
000000  4801              LDR      r0,|L7.8|
;;;45     	return cnt;
000002  6800              LDR      r0,[r0,#0]  ; cnt
;;;46     }
000004  4770              BX       lr
;;;47     
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      ||cnt||

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;110    *******************************************************************************/
;;;111    void HardFault_Handler(void)
000000  bf00              NOP      
                  |L8.2|
;;;112    {
;;;113        //当硬件错误发生时进入死循环 
;;;114        while (1)
000002  e7fe              B        |L8.2|
;;;115        {
;;;116        }
;;;117    }
;;;118    
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;125    *******************************************************************************/
;;;126    void MemManage_Handler(void)
000000  bf00              NOP      
                  |L9.2|
;;;127    {
;;;128        //当内存管理中断发生时进入死循环 
;;;129        while (1)
000002  e7fe              B        |L9.2|
;;;130        {
;;;131        }
;;;132    }
;;;133    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;99     *******************************************************************************/
;;;100    void NMI_Handler(void)
000000  4770              BX       lr
;;;101    {
;;;102    }
;;;103    
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;192    *******************************************************************************/
;;;193    void PendSV_Handler(void)
000000  4770              BX       lr
;;;194    {
;;;195    }
;;;196    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;170    *******************************************************************************/
;;;171    void SVC_Handler(void)
000000  4770              BX       lr
;;;172    {
;;;173    }
;;;174    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;203    *******************************************************************************/
;;;204    void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206    	cnt++;
000002  4806              LDR      r0,|L13.28|
000004  6800              LDR      r0,[r0,#0]  ; cnt
000006  1c40              ADDS     r0,r0,#1
000008  4904              LDR      r1,|L13.28|
00000a  6008              STR      r0,[r1,#0]  ; cnt
;;;207    	delay_cnt++;
00000c  4804              LDR      r0,|L13.32|
00000e  6800              LDR      r0,[r0,#0]  ; delay_cnt
000010  1c40              ADDS     r0,r0,#1
000012  4903              LDR      r1,|L13.32|
000014  6008              STR      r0,[r1,#0]  ; delay_cnt
;;;208    	
;;;209    	key_prograss();
000016  f7fffffe          BL       key_prograss
;;;210    	return;
;;;211    }
00001a  bd10              POP      {r4,pc}
;;;212    
                          ENDP

                  |L13.28|
                          DCD      ||cnt||
                  |L13.32|
                          DCD      delay_cnt

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;155    *******************************************************************************/
;;;156    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L14.2|
;;;157    {
;;;158        //当Usage 错误发生时进入死循环 
;;;159        while (1)
000002  e7fe              B        |L14.2|
;;;160        {
;;;161        }
;;;162    }
;;;163    
                          ENDP


                          AREA ||i.key_prograss||, CODE, READONLY, ALIGN=2

                  key_prograss PROC
;;;55     //防抖处理
;;;56     void key_prograss(void){
000000  b510              PUSH     {r4,lr}
;;;57     	int i;
;;;58     
;;;59     #if 0	
;;;60     	if(key.busy){
;;;61     		if(!GPIO_ReadInputDataBit(key.GPIOx, key.GPIO_Pin)){
;;;62     				key.delay++;
;;;63     		}else{
;;;64     				key.busy = 0;
;;;65     		}
;;;66     		if(key.delay > 50){
;;;67     			put_key(key.key_value);
;;;68     			key.busy = 0;
;;;69     		}
;;;70     	}
;;;71     #endif
;;;72     	for(i=0; i<14; i++){
000002  2400              MOVS     r4,#0
000004  e051              B        |L15.170|
                  |L15.6|
;;;73     		if(!GPIO_ReadInputDataBit(key[i].GPIOx, key[i].GPIO_Pin)){
000006  eb040244          ADD      r2,r4,r4,LSL #1
00000a  4b29              LDR      r3,|L15.176|
00000c  eb0302c2          ADD      r2,r3,r2,LSL #3
000010  8891              LDRH     r1,[r2,#4]
000012  eb040244          ADD      r2,r4,r4,LSL #1
000016  f8530032          LDR      r0,[r3,r2,LSL #3]
00001a  f7fffffe          BL       GPIO_ReadInputDataBit
00001e  bb78              CBNZ     r0,|L15.128|
;;;74     			key[i].touch_flag = 1;
000020  2001              MOVS     r0,#1
000022  eb040144          ADD      r1,r4,r4,LSL #1
000026  4a22              LDR      r2,|L15.176|
000028  eb0201c1          ADD      r1,r2,r1,LSL #3
00002c  60c8              STR      r0,[r1,#0xc]
;;;75     			key[i].delay++;
00002e  eb040044          ADD      r0,r4,r4,LSL #1
000032  4611              MOV      r1,r2
000034  eb0100c0          ADD      r0,r1,r0,LSL #3
000038  6880              LDR      r0,[r0,#8]
00003a  1c40              ADDS     r0,r0,#1
00003c  eb040144          ADD      r1,r4,r4,LSL #1
000040  eb0201c1          ADD      r1,r2,r1,LSL #3
000044  6088              STR      r0,[r1,#8]
;;;76     			if((key[i].delay > 50) && key[i].untouch_flag){
000046  eb040044          ADD      r0,r4,r4,LSL #1
00004a  4611              MOV      r1,r2
00004c  eb0100c0          ADD      r0,r1,r0,LSL #3
000050  6880              LDR      r0,[r0,#8]
000052  2832              CMP      r0,#0x32
000054  d928              BLS      |L15.168|
000056  eb040044          ADD      r0,r4,r4,LSL #1
00005a  eb0100c0          ADD      r0,r1,r0,LSL #3
00005e  6900              LDR      r0,[r0,#0x10]
000060  b310              CBZ      r0,|L15.168|
;;;77     				put_key(key[i].key_value);
000062  eb040144          ADD      r1,r4,r4,LSL #1
000066  eb0201c1          ADD      r1,r2,r1,LSL #3
00006a  7d08              LDRB     r0,[r1,#0x14]
00006c  f7fffffe          BL       put_key
;;;78     				key[i].untouch_flag = 0;
000070  2000              MOVS     r0,#0
000072  eb040144          ADD      r1,r4,r4,LSL #1
000076  4a0e              LDR      r2,|L15.176|
000078  eb0201c1          ADD      r1,r2,r1,LSL #3
00007c  6108              STR      r0,[r1,#0x10]
00007e  e013              B        |L15.168|
                  |L15.128|
000080  e7ff              B        |L15.130|
                  |L15.130|
;;;79     			}
;;;80     		}else{
;;;81     			key[i].delay = 0;
000082  2000              MOVS     r0,#0
000084  eb040144          ADD      r1,r4,r4,LSL #1
000088  4a09              LDR      r2,|L15.176|
00008a  eb0201c1          ADD      r1,r2,r1,LSL #3
00008e  6088              STR      r0,[r1,#8]
;;;82     			key[i].untouch_flag = 1;
000090  2001              MOVS     r0,#1
000092  eb040144          ADD      r1,r4,r4,LSL #1
000096  eb0201c1          ADD      r1,r2,r1,LSL #3
00009a  6108              STR      r0,[r1,#0x10]
;;;83     			key[i].touch_flag = 0;
00009c  2000              MOVS     r0,#0
00009e  eb040144          ADD      r1,r4,r4,LSL #1
0000a2  eb0201c1          ADD      r1,r2,r1,LSL #3
0000a6  60c8              STR      r0,[r1,#0xc]
                  |L15.168|
0000a8  1c64              ADDS     r4,r4,#1              ;72
                  |L15.170|
0000aa  2c0e              CMP      r4,#0xe               ;72
0000ac  dbab              BLT      |L15.6|
;;;84     		}
;;;85     	}
;;;86     	return;
;;;87     }
0000ae  bd10              POP      {r4,pc}
;;;88     
                          ENDP

                  |L15.176|
                          DCD      key

                          AREA ||.data||, DATA, ALIGN=2

                  ||cnt||
                          DCD      0x00000000
                  delay_cnt
                          DCD      0x00000000
                  key
                          DCD      0x40011000
00000c  0040              DCW      0x0040
00000e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
00001c  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      0x40011000
000024  0080              DCW      0x0080
000026  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
000034  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      0x40011000
00003c  0100              DCW      0x0100
00003e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
00004c  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      0x40011000
000054  0200              DCW      0x0200
000056  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
000064  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x40010800
00006c  0100              DCW      0x0100
00006e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
00007c  0b000000          DCB      0x0b,0x00,0x00,0x00
                          DCD      0x40010800
000084  0200              DCW      0x0200
000086  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
000094  09000000          DCB      0x09,0x00,0x00,0x00
                          DCD      0x40010800
00009c  0400              DCW      0x0400
00009e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
0000ac  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      0x40010800
0000b4  0800              DCW      0x0800
0000b6  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
0000c4  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      0x40010800
0000cc  1000              DCW      0x1000
0000ce  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
0000dc  0d000000          DCB      0x0d,0x00,0x00,0x00
                          DCD      0x40010c00
0000e4  0800              DCW      0x0800
0000e6  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
0000f4  0c000000          DCB      0x0c,0x00,0x00,0x00
                          DCD      0x40010c00
0000fc  1000              DCW      0x1000
0000fe  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
00010c  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      0x40010c00
000114  2000              DCW      0x2000
000116  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
000124  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      0x40010c00
00012c  4000              DCW      0x4000
00012e  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
00013c  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      0x40010c00
000144  8000              DCW      0x8000
000146  0000              DCB      0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
000154  0a000000          DCB      0x0a,0x00,0x00,0x00
