; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Output\stm32f10x_rtc.o --depend=.\Output\stm32f10x_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\User -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\bsp_lib -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Output\stm32f10x_rtc.crf ..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;89       */
;;;90     void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
000000  b139              CBZ      r1,|L1.18|
;;;91     {
;;;92       /* Check the parameters */
;;;93       assert_param(IS_RTC_IT(RTC_IT));  
;;;94       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;95       
;;;96       if (NewState != DISABLE)
;;;97       {
;;;98         RTC->CRH |= RTC_IT;
000002  4a55              LDR      r2,|L1.344|
000004  8812              LDRH     r2,[r2,#0]
000006  ea420200          ORR      r2,r2,r0
00000a  4b54              LDR      r3,|L1.348|
00000c  f8a32800          STRH     r2,[r3,#0x800]
000010  e009              B        |L1.38|
                  |L1.18|
;;;99       }
;;;100      else
;;;101      {
;;;102        RTC->CRH &= (uint16_t)~RTC_IT;
000012  4a51              LDR      r2,|L1.344|
000014  8812              LDRH     r2,[r2,#0]
000016  ea6f0300          MVN      r3,r0
00001a  b29b              UXTH     r3,r3
00001c  ea020203          AND      r2,r2,r3
000020  4b4e              LDR      r3,|L1.348|
000022  f8a32800          STRH     r2,[r3,#0x800]
                  |L1.38|
;;;103      }
;;;104    }
000026  4770              BX       lr
;;;105    
                          ENDP

                  RTC_EnterConfigMode PROC
;;;110      */
;;;111    void RTC_EnterConfigMode(void)
000028  484d              LDR      r0,|L1.352|
;;;112    {
;;;113      /* Set the CNF flag to enter in the Configuration Mode */
;;;114      RTC->CRL |= RTC_CRL_CNF;
00002a  8800              LDRH     r0,[r0,#0]
00002c  f0400010          ORR      r0,r0,#0x10
000030  494a              LDR      r1,|L1.348|
000032  f8a10804          STRH     r0,[r1,#0x804]
;;;115    }
000036  4770              BX       lr
;;;116    
                          ENDP

                  RTC_ExitConfigMode PROC
;;;121      */
;;;122    void RTC_ExitConfigMode(void)
000038  4849              LDR      r0,|L1.352|
;;;123    {
;;;124      /* Reset the CNF flag to exit from the Configuration Mode */
;;;125      RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
00003a  8800              LDRH     r0,[r0,#0]
00003c  f64f71ef          MOV      r1,#0xffef
000040  ea000001          AND      r0,r0,r1
000044  4945              LDR      r1,|L1.348|
000046  f8a10804          STRH     r0,[r1,#0x804]
;;;126    }
00004a  4770              BX       lr
;;;127    
                          ENDP

                  RTC_GetCounter PROC
;;;132      */
;;;133    uint32_t RTC_GetCounter(void)
00004c  2100              MOVS     r1,#0
;;;134    {
;;;135      uint16_t tmp = 0;
;;;136      tmp = RTC->CNTL;
00004e  4845              LDR      r0,|L1.356|
000050  8801              LDRH     r1,[r0,#0]
;;;137      return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;
000052  4842              LDR      r0,|L1.348|
000054  f8b00818          LDRH     r0,[r0,#0x818]
000058  ea414000          ORR      r0,r1,r0,LSL #16
;;;138    }
00005c  4770              BX       lr
;;;139    
                          ENDP

                  RTC_SetCounter PROC
;;;144      */
;;;145    void RTC_SetCounter(uint32_t CounterValue)
00005e  b500              PUSH     {lr}
;;;146    { 
000060  4602              MOV      r2,r0
;;;147      RTC_EnterConfigMode();
000062  f7fffffe          BL       RTC_EnterConfigMode
;;;148      /* Set RTC COUNTER MSB word */
;;;149      RTC->CNTH = CounterValue >> 16;
000066  0c10              LSRS     r0,r2,#16
000068  493f              LDR      r1,|L1.360|
00006a  8008              STRH     r0,[r1,#0]
;;;150      /* Set RTC COUNTER LSB word */
;;;151      RTC->CNTL = (CounterValue & RTC_LSB_MASK);
00006c  493b              LDR      r1,|L1.348|
00006e  f8a1281c          STRH     r2,[r1,#0x81c]
;;;152      RTC_ExitConfigMode();
000072  f7fffffe          BL       RTC_ExitConfigMode
;;;153    }
000076  bd00              POP      {pc}
;;;154    
                          ENDP

                  RTC_SetPrescaler PROC
;;;159      */
;;;160    void RTC_SetPrescaler(uint32_t PrescalerValue)
000078  b500              PUSH     {lr}
;;;161    {
00007a  4602              MOV      r2,r0
;;;162      /* Check the parameters */
;;;163      assert_param(IS_RTC_PRESCALER(PrescalerValue));
;;;164      
;;;165      RTC_EnterConfigMode();
00007c  f7fffffe          BL       RTC_EnterConfigMode
;;;166      /* Set RTC PRESCALER MSB word */
;;;167      RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
000080  f3c24003          UBFX     r0,r2,#16,#4
000084  4939              LDR      r1,|L1.364|
000086  8008              STRH     r0,[r1,#0]
;;;168      /* Set RTC PRESCALER LSB word */
;;;169      RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
000088  4934              LDR      r1,|L1.348|
00008a  f8a1280c          STRH     r2,[r1,#0x80c]
;;;170      RTC_ExitConfigMode();
00008e  f7fffffe          BL       RTC_ExitConfigMode
;;;171    }
000092  bd00              POP      {pc}
;;;172    
                          ENDP

                  RTC_SetAlarm PROC
;;;177      */
;;;178    void RTC_SetAlarm(uint32_t AlarmValue)
000094  b500              PUSH     {lr}
;;;179    {  
000096  4602              MOV      r2,r0
;;;180      RTC_EnterConfigMode();
000098  f7fffffe          BL       RTC_EnterConfigMode
;;;181      /* Set the ALARM MSB word */
;;;182      RTC->ALRH = AlarmValue >> 16;
00009c  0c10              LSRS     r0,r2,#16
00009e  4934              LDR      r1,|L1.368|
0000a0  8008              STRH     r0,[r1,#0]
;;;183      /* Set the ALARM LSB word */
;;;184      RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
0000a2  492e              LDR      r1,|L1.348|
0000a4  f8a12824          STRH     r2,[r1,#0x824]
;;;185      RTC_ExitConfigMode();
0000a8  f7fffffe          BL       RTC_ExitConfigMode
;;;186    }
0000ac  bd00              POP      {pc}
;;;187    
                          ENDP

                  RTC_GetDivider PROC
;;;192      */
;;;193    uint32_t RTC_GetDivider(void)
0000ae  2000              MOVS     r0,#0
;;;194    {
;;;195      uint32_t tmp = 0x00;
;;;196      tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
0000b0  4930              LDR      r1,|L1.372|
0000b2  8809              LDRH     r1,[r1,#0]
0000b4  ea4f7101          LSL      r1,r1,#28
0000b8  ea4f3011          LSR      r0,r1,#12
;;;197      tmp |= RTC->DIVL;
0000bc  4927              LDR      r1,|L1.348|
0000be  f8b11814          LDRH     r1,[r1,#0x814]
0000c2  ea410000          ORR      r0,r1,r0
;;;198      return tmp;
;;;199    }
0000c6  4770              BX       lr
;;;200    
                          ENDP

                  RTC_WaitForLastTask PROC
;;;206      */
;;;207    void RTC_WaitForLastTask(void)
0000c8  bf00              NOP      
                  |L1.202|
;;;208    {
;;;209      /* Loop until RTOFF flag is set */
;;;210      while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
0000ca  4825              LDR      r0,|L1.352|
0000cc  8800              LDRH     r0,[r0,#0]
0000ce  f0100f20          TST      r0,#0x20
0000d2  d0fa              BEQ      |L1.202|
;;;211      {
;;;212      }
;;;213    }
0000d4  4770              BX       lr
;;;214    
                          ENDP

                  RTC_WaitForSynchro PROC
;;;222      */
;;;223    void RTC_WaitForSynchro(void)
0000d6  4822              LDR      r0,|L1.352|
;;;224    {
;;;225      /* Clear RSF flag */
;;;226      RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
0000d8  8800              LDRH     r0,[r0,#0]
0000da  f64f71f7          MOV      r1,#0xfff7
0000de  ea000001          AND      r0,r0,r1
0000e2  491e              LDR      r1,|L1.348|
0000e4  f8a10804          STRH     r0,[r1,#0x804]
;;;227      /* Loop until RSF flag is set */
;;;228      while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
0000e8  bf00              NOP      
                  |L1.234|
0000ea  481d              LDR      r0,|L1.352|
0000ec  8800              LDRH     r0,[r0,#0]
0000ee  f0100f08          TST      r0,#8
0000f2  d0fa              BEQ      |L1.234|
;;;229      {
;;;230      }
;;;231    }
0000f4  4770              BX       lr
;;;232    
                          ENDP

                  RTC_GetFlagStatus PROC
;;;243      */
;;;244    FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
0000f6  4601              MOV      r1,r0
;;;245    {
;;;246      FlagStatus bitstatus = RESET;
0000f8  2000              MOVS     r0,#0
;;;247      
;;;248      /* Check the parameters */
;;;249      assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
;;;250      
;;;251      if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
0000fa  4a19              LDR      r2,|L1.352|
0000fc  8812              LDRH     r2,[r2,#0]
0000fe  420a              TST      r2,r1
000100  d001              BEQ      |L1.262|
;;;252      {
;;;253        bitstatus = SET;
000102  2001              MOVS     r0,#1
000104  e000              B        |L1.264|
                  |L1.262|
;;;254      }
;;;255      else
;;;256      {
;;;257        bitstatus = RESET;
000106  2000              MOVS     r0,#0
                  |L1.264|
;;;258      }
;;;259      return bitstatus;
;;;260    }
000108  4770              BX       lr
;;;261    
                          ENDP

                  RTC_ClearFlag PROC
;;;272      */
;;;273    void RTC_ClearFlag(uint16_t RTC_FLAG)
00010a  4915              LDR      r1,|L1.352|
;;;274    {
;;;275      /* Check the parameters */
;;;276      assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
;;;277        
;;;278      /* Clear the corresponding RTC flag */
;;;279      RTC->CRL &= (uint16_t)~RTC_FLAG;
00010c  8809              LDRH     r1,[r1,#0]
00010e  ea6f0200          MVN      r2,r0
000112  b292              UXTH     r2,r2
000114  ea010102          AND      r1,r1,r2
000118  4a10              LDR      r2,|L1.348|
00011a  f8a21804          STRH     r1,[r2,#0x804]
;;;280    }
00011e  4770              BX       lr
;;;281    
                          ENDP

                  RTC_GetITStatus PROC
;;;290      */
;;;291    ITStatus RTC_GetITStatus(uint16_t RTC_IT)
000120  4601              MOV      r1,r0
;;;292    {
;;;293      ITStatus bitstatus = RESET;
000122  2000              MOVS     r0,#0
;;;294      /* Check the parameters */
;;;295      assert_param(IS_RTC_GET_IT(RTC_IT)); 
;;;296      
;;;297      bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
000124  4a0e              LDR      r2,|L1.352|
000126  8812              LDRH     r2,[r2,#0]
000128  ea020201          AND      r2,r2,r1
00012c  b2d0              UXTB     r0,r2
;;;298      if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
00012e  4a0b              LDR      r2,|L1.348|
000130  f8b22800          LDRH     r2,[r2,#0x800]
000134  420a              TST      r2,r1
000136  d002              BEQ      |L1.318|
000138  b108              CBZ      r0,|L1.318|
;;;299      {
;;;300        bitstatus = SET;
00013a  2001              MOVS     r0,#1
00013c  e000              B        |L1.320|
                  |L1.318|
;;;301      }
;;;302      else
;;;303      {
;;;304        bitstatus = RESET;
00013e  2000              MOVS     r0,#0
                  |L1.320|
;;;305      }
;;;306      return bitstatus;
;;;307    }
000140  4770              BX       lr
;;;308    
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;317      */
;;;318    void RTC_ClearITPendingBit(uint16_t RTC_IT)
000142  4907              LDR      r1,|L1.352|
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_RTC_IT(RTC_IT));  
;;;322      
;;;323      /* Clear the corresponding RTC pending bit */
;;;324      RTC->CRL &= (uint16_t)~RTC_IT;
000144  8809              LDRH     r1,[r1,#0]
000146  ea6f0200          MVN      r2,r0
00014a  b292              UXTH     r2,r2
00014c  ea010102          AND      r1,r1,r2
000150  4a02              LDR      r2,|L1.348|
000152  f8a21804          STRH     r1,[r2,#0x804]
;;;325    }
000156  4770              BX       lr
;;;326    
                          ENDP

                  |L1.344|
                          DCD      0x40002800
                  |L1.348|
                          DCD      0x40002000
                  |L1.352|
                          DCD      0x40002804
                  |L1.356|
                          DCD      0x4000281c
                  |L1.360|
                          DCD      0x40002818
                  |L1.364|
                          DCD      0x40002808
                  |L1.368|
                          DCD      0x40002820
                  |L1.372|
                          DCD      0x40002810
